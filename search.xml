<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring注解详解(一)]]></title>
    <url>%2F2019%2F01%2F09%2Fspring%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[spring中的注解(一)springMVC中注解​ 在了解springMVC注解之前,我们先了解springMVC的架构流程 ​ 1:用户发送请求到DispatcherServlet控制器(以下简称控制器) ​ 2:控制器通过请求的路径在HandlerMapping映射器中查询handler处理器 ​ 3:映射器再根据用户的请求查找相对应的HandleExecutionChain执行链传向控制器 ​ 4. 控制器根据handler具体的实现方式调用HandlerAdapter适配器 ​ 5:适配器调用具体的handler处理器处理业务并返回ModelAndView到DispatcherServlet控制器 ​ 6:控制器将ModelAndView专递到ViewResolver视图解析器 ​ 7:视图解析器 返回具体的视图到控制器 ​ 8:控制器渲染视图后响应给用户 1:@Controller​ Controller控制器用于处理DispatcherServlet所分发出来的请求,将请求数据通过业务处理层封装为一个Model,将Model返回视图层进行展示; ​ SpringMVC提供了一个简便与定义Controller的方法;只要在一个类的上方加上@Controller的注解就可以声明这个类是一个Controller对象 ​ 但是如果只是这样还不行,必须让spring管理 ​ 1:在springMVC配置文件中配置Controller的Bean对象 1&lt;bean id="id为这个Bean的名称" class="class属性指定了Bean对应的实现类"&gt;&lt;/bean&gt; ​ 2:在springMVC配置文件中指定Controller的URL地址 1&lt; context:component-scan base-package="spring通过扫描类包来加载利用注解定义的Bean的方式" resource-pattern="用来过滤出特定的类"/ &gt; 2:@RequestMapping()​ RequestMapping注解是用来处理请求地址的映射,通常用于方法上或类的上方 常用属性: value 指定的请求地址URL method 指定的请求method类型 POST GET PUT DELETE consumes 指定的请求内容类型 produces 指定的请求返回内容类 params 指定使用该方法的request中必须包含的参数 headers 指定使用该方法的request中必须包含的header值 ​ 既然说到method,那么我们了解一下HTTP方法的安全性与幂等 ​ 安全性:是指方法的多次调用不会更改资源状态(不会发生脏读,幻读,不可重复读) ​ 幂等 : 是指方法多次调用返回结果一致(在操作成功条件下,是否会对数据库造成不好的影响); POST 不安全且不幂等 GET 安全且幂等 PUI 不安全且幂等 DELETE 不安全且幂等 3:@Resource与@Autowired@Resource和@Autowired之间有相同点也有不相同之处所以就放在一起做个比较 ​ 1:相同之处在于二者都是做bean注入时使用;用于在字段上,或用于在setter方法.( @Resource并不是spring的注解, java1.6支持; javax.annotation.Resource) ​ 2:不同点 @Resource 默认通过byName自动注入;name与type时@Resource的属性;spring将name属性解析为bean的名字,type属性解析为bean的类型,使用什么属性时就默认使用什么属性注入,都不使用下默认通过反射机制byname自动注入 @Autowired 默认通过byType自动注入,默认情况下依赖必须存在,如果允许null值,则设置required属性为false,如果想要使用name属性则配合@Qualifier注解 点击显/隐代码 123456789public class UserServiceImpl implements IUserService &#123; @Resource private BasUserMapper basUserMapper; @Resource(name="redisTemplate") private ValueOperations&lt;String,Object&gt; valueOperations; &#125; 点击显/隐代码 123456public class CusDevPlanService extends BaseService&lt;CusDevPlan&gt; &#123; @Autowired private CusDevPlanMapper cusDevPlanMapper; &#125; 4:@ResponseBody与@RequestBody @ResponseBody 这个注解通常使用与方法上与@RequestMapping()一起使用,将该方法的返回值写入HTTP response body中;一般用于异步获取数据; @ResponseBody将Controller的返回值通过HttpMessageConverter转换为指定格式后,写入HTTP response @RequestBody 这个注解通常用于后端接收前台传入数据,使用HttpMessageConverter解析,最后将HttpMessageConverten返回的数据对象传递到controller的方法形参上 ​]]></content>
      <categories>
        <category>spring注解 ,springMVC</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection集合一]]></title>
    <url>%2F2019%2F01%2F06%2FCollection%E9%9B%86%E5%90%88%E4%B8%80%2F</url>
    <content type="text"><![CDATA[浅谈集合（一）在说之前我们先来了解容器，从字面上来说容器就是用来装东西的，在java中从一开始的变量来存放单个数据，到数组储存多个数据，但是数组只能存放相同类型的数据，而且数组的长度一旦确定不可改变；当存放的数据类型与个数不确定的时候数组就不太好用了，java中就提供了相关的容器； Collection 集合Collection之List可以用来储存对象，储存的数据位于堆中；当放入基本数据类型的数据时会自动转为引用数据类型；例如：当存放一个int类型的数据时，会自动转为引用数据类型Intager当在将其取出时Intager 会转为 int ；这就是自动拆装箱；Collection 位于java.util下，是所有单列集合的父接口，Collection中也提供大量操作容器的方法；​public boolean add(E e)： 把给定的对象添加到当前集合中 。public void clear() :清空集合中所有的元素。public boolean remove(E e): 把给定的对象在当前集合中删除。public boolean isEmpty(): 判断当前集合是否为空。public int size(): 返回集合中元素的个数。public Object[] toArray(): 把集合中的元素，存储到数组中。可以间接对集合进行遍历。 点击显/隐原代码 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;/** * @Author: zzy * @Date: 2018/10/20 * @Version 1.0 */public class CollectionTest &#123; public static void main(String[] args) &#123; Collection collection = new ArrayList(); //添加 ((ArrayList) collection).add(1); ((ArrayList) collection).add("a"); //遍历 Object[] arr=collection.toArray(); System.out.println(Arrays.toString(arr)); //返回集合元素个数 System.out.println(collection.size());//2 //把指定对象删除 System.out.println(collection.remove("a")); //清空 collection.clear(); //判断是否包含 System.out.println(collection.contains("a"));//false //判断集合是否为空 System.out.println(collection.isEmpty());//true &#125;&#125; ListList是Collecton的子接口；List是有序的，可重复的集合，元素都可以通过索引去获得； List继承了Collection的方法外也增加了新的方法： public void add(int index, E element)：将指定的元素，添加到该集合中的指定位置上。` public E set(int index, E element)`:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 ArrayList 与 LinkedList 和 Vector实现了List接口； 下面简单介绍三个容器中的各自的增删改查与遍历的区别； ArrayListArrayList的底层是通过可变数组实现的，简单来说就是通过数组的不断拷贝，并不断扩大数组的长度； 数组中的元素都有相对应的下标，由此可见ArrayList查询数据效率更高； 点击显/隐原代码 123456789101112131415private int newCapacity(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt;= 0) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; &#125; return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity);&#125; 在源码中我们可以看到newCapacity是在oldCapacity的基础之上扩容1.5倍； 常用方法： public boolean add(E e)`：将指定的元素添加到此集合的尾部。 public E remove(int index)` ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index)` ：返回此集合中指定位置上的元素。返回获取的元素。 public int size()` ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。类似于数组里面的length属性 public set(int index, E element)`: 可以设置指定位置的元素 点击显/隐代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.Iterator;/** * @Author: zzy * @Date: 2018/10/20 * @Version 1.0 */public class ArrayListTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt;list = new ArrayList&lt;&gt;(); //增 list.add("A"); list.add("B"); list.add("C"); list.add("D"); //删 list.remove("A"); //获得 list.get(2); //改 list.set(1,"E"); //判断是否为空 list.isEmpty(); //遍历 三种方式 //普通for循环 for (int i = 0; i &lt;list.size() ; i++) &#123; System.out.println(list); &#125; //增强for循环 for (String str:list) &#123; System.out.println(str); &#125; //迭代器遍历 Iterator it = list.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; LinkedListLinkedList底层是双链表结构； 单链表 如图中所示，在链表结构中，每一个节点都是一分为二，前面存放数据后面存放下一个节点的位置；而链表的最后一位没有下一节点的位置时，此时为null; 像这一种称为单向链表； 双向链表 而像图中这种称为双向链表，将一个节点分为三份，第一份放上一个节点的位置，中间放数据，最后放下一个节点的位置； 链表结构添加数据，删除数据效率更高；因为不管添加还是删除只需知道下一节点的位置就可以更改，而且不会改变其他位置的数据，但它查询数据是从头到尾；所以查询数据效率就偏低 常用方法： public void addFirst(E e)`:将指定元素插入此列表的开头。 public void addLast(E e)`:将指定元素添加到此列表的结尾。 public E getFirst()`:返回此列表的第一个元素。 public E getLast()`:返回此列表的最后一个元素。 public E removeFirst()`:移除并返回此列表的第一个元素。 public E removeLast()`:移除并返回此列表的最后一个元素。 点击显/隐代码 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Iterator;import java.util.LinkedList;/** * @Author: zzy * @Date: 2018/10/20 * @Version 1.0 */public class LinkedListTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt;linkedList = new LinkedList&lt;&gt;(); linkedList.addFirst("添加到开头"); linkedList.addLast("添加到结尾"); //获取 linkedList.getFirst(); linkedList.getLast(); //判断是否为空 linkedList.isEmpty(); for (String str:linkedList)&#123; System.out.println(str); &#125; Iterator it = linkedList.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125; //删除 linkedList.removeLast(); linkedList.removeFirst(); &#125;&#125; Vectorvector对于学习C语言的人来说肯定是不陌生；Vector的底层也是可变数组；它与ArrayList的区别是加了synchronized同步锁；线程是安全的；线程安全一般效率偏低;ArrayList与LinkedList都是线程不安全的。但是效率相对而言要高；之前提过ArrayList的底层数组是以每次扩容0,5倍，而Vector是扩容1倍； 常用方法：add(E e) 将指定的元素追加到此Vector的末尾 void add(int index, Object element) 在此向量的指定位置插入指定的元素。 int capacity()返回此向量的当前容量。 void clear()从此向量中移除所有元素。 boolean contains(Object elem)如果此向量包含指定的元素，则返回 true。 Object remove(int index) 移除此向量中指定位置的元素 String toString()返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式。 add(int index, E element) 在此Vector中的指定位置插入指定的元素 add(int index, E element)在此Vector中的指定位置插入指定的元素 点击显/隐代码 12345678910111213141516171819202122232425262728293031323334import java.util.Vector;/** * @Author: zzy * @Date: 2018/10/20 11:13 * @Version 1.0 */public class VectorTest &#123; public static void main(String[] args) &#123; Vector vector = new Vector(); vector.add(0,"A"); vector.add(1,"C"); //添加到最后 vector.add("B"); //返回长度 vector.capacity(); //移除 vector.remove(1); //判断包含 vector.contains("B");//false //字符串表示 System.out.println(vector.toString()); //清空 vector.clear(); &#125;&#125;]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从oop到ooa]]></title>
    <url>%2F2019%2F01%2F05%2F%E4%BB%8Eoop%E5%88%B0ooa%2F</url>
    <content type="text"><![CDATA[从OOP—》OOA—》OOD—》OOP6大设计原则： 单一职责原则： 引起一个类发生变化的因素不要超过一个；一个类只能有一 种职责，类中可以有多个方法 开闭原则： 对扩展开放，对修改关闭，再不改变类的前提下扩展一个类的职能；低耦合，高内聚！ 里氏替换原则 任何父类的引用的函数必须能使用继承类的对象，保证继承能正确使用方法 接口分离原则 类的依赖关系应当建立在最小的接口，接口应当只包含不同类中的共同方法； 依赖倒置原则：{是开闭原则的前提} 低层模块：不可分割原子性，高层模块：低层模块的再组合，对低层模块的抽象，抽象：接口或抽象类实现类：低层模块的具体实实现类： 迪米特原则： 类与类之间因有不可见，封装 1暂时理解：面向接口编程，函数式编程 模块间的依赖通过抽象类或接口产生，实现类之间的依赖关系也是通过抽象类或接口产生（要求：实现类之间应当不发生直接依赖关系），已达到降低系统的低耦合 接口或抽象类不依赖与实现类，但实现类依赖接口和抽象类，以实现类对系统功能具体体现，已达到更高的高内聚 OOA面向对象分析理解问题与需求架构{简单而言}1：完成用户要求系统应提供哪些功能 2：系统应该有哪些对象构成 3：每个对象应有哪些属性和服务（功能） 4：对象之间应当建立怎样的联系 五种层次 五种活动 主题层 标识类对象 对象类层 标识结构 结构层 定义主题 属性层 定义属性 要知道一个类与另一个类的实例映射关系 服务层 定义服务 一个对象需要对另一个对象发送消息 从而定义两种对象类之间的结构； 1：分类结构 一般与特殊的关系 2：组合结构 对象之间整体与部分的关系 如何做：1：抽象： 从多个事物中舍弃个别的，非本质的特征，抽取共同的，本质性的特征。 123数据抽象：简单来说就是的（数据和操作）属性与功能结合为一个系统单位（对象），对象为不不需要知道对象内部有什么。过程抽象： 任何一个完成确定功能的方法，都应该看作是一个单一的实体，不必在乎内部是低级操作完成 2：封装：把对象的属性与服务结合到一个不可分的系统单位（类）隐藏内部细节 3：继承：子类对象拥有父类的所有属性以及功能 4：分类：把属性与服务相同的对象分为一类，用类来作为对象的抽象描述 5：聚合：把一个复杂的事物看成是若干个比较简单的事物组成的，简化对事物的描述 6：关联；通过一个事物想到另一个事物，是因为事物之间有联系 7：消息通信：对象中间通过信息传递，不允许在对象之外获得联系（即封装） 8：粒度控制：在考虑全局时，注意大的组成部分，暂时不看小的具体细节；考虑某部分细节时，暂时撇开其余组成部分 9：行为分析： 步骤： 确定对象和类 类是多个对象的共同属性和方法的集合 确定结构 确定主题 确定属性 确定方法]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
