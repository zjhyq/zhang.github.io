<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring注解详解(一)]]></title>
    <url>%2F2019%2F01%2F09%2Fspring%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[spring中的注解(一)springMVC中注解​ 在了解springMVC注解之前,我们先了解springMVC的架构流程 ​ 1:用户发送请求到DispatcherServlet控制器(以下简称控制器) ​ 2:控制器通过请求的路径在HandlerMapping映射器中查询handler处理器 ​ 3:映射器再根据用户的请求查找相对应的HandleExecutionChain执行链传向控制器 ​ 4. 控制器根据handler具体的实现方式调用HandlerAdapter适配器 ​ 5:适配器调用具体的handler处理器处理业务并返回ModelAndView到DispatcherServlet控制器 ​ 6:控制器将ModelAndView专递到ViewResolver视图解析器 ​ 7:视图解析器 返回具体的视图到控制器 ​ 8:控制器渲染视图后响应给用户 1:@Controller与@Service与@Component与@Repository​ @Controller(注入服务) ​ @Component 泛指各种组件，相当于一个bean(&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;) ，可以在任何层使用。 ​ @Service(注入dao) 通常用于业务层 ​ @Repository DOA组件 ​ Controller控制器用于处理DispatcherServlet所分发出来的请求,将请求数据通过业务处理层封装为一个Model,将Model返回视图层进行展示;与 @Component 相同 ​ SpringMVC提供了一个简便与定义Controller的方法;只要在一个类的上方加上@Controller的注解就可以声明这个类是一个Controller对象 ​ 但是如果只是这样还不行,必须让spring管理 ​ 1:在springMVC配置文件中配置Controller的Bean对象 1&lt;bean id="id为这个Bean的名称" class="class属性指定了Bean对应的实现类"&gt;&lt;/bean&gt; ​ 2:在springMVC配置文件中指定Controller的URL地址 1&lt; context:component-scan base-package="spring通过扫描类包来加载利用注解定义的Bean的方式" resource-pattern="用来过滤出特定的类"/ &gt; 2:@RequestMapping()​ RequestMapping注解是用来处理请求地址的映射,通常用于方法上或类的上方 常用属性: value 指定的请求地址URL method 指定的请求method类型 POST GET PUT DELETE consumes 指定的请求内容类型 produces 指定的请求返回内容类 params 指定使用该方法的request中必须包含的参数 headers 指定使用该方法的request中必须包含的header值 ​ 既然说到method,那么我们了解一下HTTP方法的安全性与幂等 ​ 安全性:是指方法的多次调用不会更改资源状态(不会发生脏读,幻读,不可重复读) ​ 幂等 : 是指方法多次调用返回结果一致(在操作成功条件下,是否会对数据库造成不好的影响); POST 不安全且不幂等 GET 安全且幂等 PUI 不安全且幂等 DELETE 不安全且幂等 3:@Resource与@Autowired@Resource和@Autowired之间有相同点也有不相同之处所以就放在一起做个比较 ​ 1:相同之处在于二者都是做bean注入时使用;用于在字段上,或用于在setter方法.( @Resource并不是spring的注解, java1.6支持; javax.annotation.Resource) ​ 2:不同点 @Resource 默认通过byName自动注入;name与type时@Resource的属性;spring将name属性解析为bean的名字,type属性解析为bean的类型,使用什么属性时就默认使用什么属性注入,都不使用下默认通过反射机制byname自动注入 @Autowired 默认通过byType自动注入,默认情况下依赖必须存在,如果允许null值,则设置required属性为false,如果想要使用name属性则配合@Qualifier注解 点击**@Resource**显/隐代码 123456789public class UserServiceImpl implements IUserService &#123; @Resource private BasUserMapper basUserMapper; @Resource(name="redisTemplate") private ValueOperations&lt;String,Object&gt; valueOperations; &#125; 点击**@Autowired**显/隐代码 123456public class CusDevPlanService extends BaseService&lt;CusDevPlan&gt; &#123; @Autowired private CusDevPlanMapper cusDevPlanMapper; &#125; 4:@ResponseBody与@RequestBody @ResponseBody 这个注解通常使用与方法上与@RequestMapping()一起使用,将该方法的返回值写入HTTP response body中;一般用于异步获取数据; @ResponseBody将Controller的返回值通过HttpMessageConverter转换为指定格式后,写入HTTP response @RequestBody 这个注解通常用于后端接收前台传入数据,使用HttpMessageConverter解析,最后将HttpMessageConverten返回的数据对象传递到controller的方法形参上 ​ 下面举个小栗子 点击显/隐代码 1234567891011121314151617181920//前台检验参数后发送ajax请求到后台$.ajax(&#123; type: 'post', url: '/user/login', data:&#123; userName: username, userPwd: password &#125;, success:function (data) &#123; if(data.code==200)&#123; alert("登陆成功"); // 记录cookie信息 $.cookie("userIdStr", data.result.userIdStr); // 跳转主页 window.location.href = '/main'; &#125;else&#123; alert(data.msg); &#125; &#125;&#125;); Controller层 12345678910111213141516171819@Controller@RequestMapping("user")public class UserController extends BaseController&#123; @Autowired private UserService userService; @RequestMapping("index") public String index()&#123; return "user"; &#125; @RequestMapping("login") @ResponseBody public ResultInfo login(String userName, String userPwd) &#123; //交给service层处理 UserInfo userInfo = userService.userLogin(userName, userPwd); return success("登陆成功", userInfo); &#125;&#125; 5:@PathVariable与@requestParam @PathVariable 将 路径当做参数,URL 中占位符参数绑定到控制器处理方法的形参中; 1234567@RequestMapping(&quot;login/&#123;id&#125;/&#123;pwd&#125;&quot;)@ResponseBodypublic String test(@PathVariable(&quot;id&quot;) String id,@PathVariable(&quot;pwd&quot;) String pwd)&#123; return &quot;root&quot;+&quot;1234&quot; ;&#125;//访问http:8080/login/id/pwd//root1234 @requestParam是从请求里面获取参数。 例如 Get请求 http://localhost:8080/login?/id=root&amp;name=root 123456@RequestMapping(value="login")@ResponseBodypublic String test(@requestParam("id") String id,@requestParam("name") String name)&#123; System.out.println("id :"+id+" name :"+name);&#125;输出id:root name:root 未完待续…]]></content>
      <categories>
        <category>spring注解 ,springMVC</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection集合一]]></title>
    <url>%2F2019%2F01%2F06%2FCollection%E9%9B%86%E5%90%88%E4%B8%80%2F</url>
    <content type="text"><![CDATA[浅谈集合（一）在说之前我们先来了解容器，从字面上来说容器就是用来装东西的，在java中从一开始的变量来存放单个数据，到数组储存多个数据，但是数组只能存放相同类型的数据，而且数组的长度一旦确定不可改变；当存放的数据类型与个数不确定的时候数组就不太好用了，java中就提供了相关的容器； Collection 集合Collection之List可以用来储存对象，储存的数据位于堆中；当放入基本数据类型的数据时会自动转为引用数据类型；例如：当存放一个int类型的数据时，会自动转为引用数据类型Intager当在将其取出时Intager 会转为 int ；这就是自动拆装箱；Collection 位于java.util下，是所有单列集合的父接口，Collection中也提供大量操作容器的方法；​public boolean add(E e)： 把给定的对象添加到当前集合中 。public void clear() :清空集合中所有的元素。public boolean remove(E e): 把给定的对象在当前集合中删除。public boolean isEmpty(): 判断当前集合是否为空。public int size(): 返回集合中元素的个数。public Object[] toArray(): 把集合中的元素，存储到数组中。可以间接对集合进行遍历。 点击显/隐原代码 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;/** * @Author: zzy * @Date: 2018/10/20 * @Version 1.0 */public class CollectionTest &#123; public static void main(String[] args) &#123; Collection collection = new ArrayList(); //添加 ((ArrayList) collection).add(1); ((ArrayList) collection).add("a"); //遍历 Object[] arr=collection.toArray(); System.out.println(Arrays.toString(arr)); //返回集合元素个数 System.out.println(collection.size());//2 //把指定对象删除 System.out.println(collection.remove("a")); //清空 collection.clear(); //判断是否包含 System.out.println(collection.contains("a"));//false //判断集合是否为空 System.out.println(collection.isEmpty());//true &#125;&#125; ListList是Collecton的子接口；List是有序的，可重复的集合，元素都可以通过索引去获得； List继承了Collection的方法外也增加了新的方法： public void add(int index, E element)：将指定的元素，添加到该集合中的指定位置上。` public E set(int index, E element)`:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 ArrayList 与 LinkedList 和 Vector实现了List接口； 下面简单介绍三个容器中的各自的增删改查与遍历的区别； ArrayListArrayList的底层是通过可变数组实现的，简单来说就是通过数组的不断拷贝，并不断扩大数组的长度； 数组中的元素都有相对应的下标，由此可见ArrayList查询数据效率更高； 点击显/隐原代码 123456789101112131415private int newCapacity(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt;= 0) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; &#125; return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity);&#125; 在源码中我们可以看到newCapacity是在oldCapacity的基础之上扩容1.5倍； 常用方法： public boolean add(E e)`：将指定的元素添加到此集合的尾部。 public E remove(int index)` ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index)` ：返回此集合中指定位置上的元素。返回获取的元素。 public int size()` ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。类似于数组里面的length属性 public set(int index, E element)`: 可以设置指定位置的元素 点击显/隐代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.Iterator;/** * @Author: zzy * @Date: 2018/10/20 * @Version 1.0 */public class ArrayListTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt;list = new ArrayList&lt;&gt;(); //增 list.add("A"); list.add("B"); list.add("C"); list.add("D"); //删 list.remove("A"); //获得 list.get(2); //改 list.set(1,"E"); //判断是否为空 list.isEmpty(); //遍历 三种方式 //普通for循环 for (int i = 0; i &lt;list.size() ; i++) &#123; System.out.println(list); &#125; //增强for循环 for (String str:list) &#123; System.out.println(str); &#125; //迭代器遍历 Iterator it = list.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; LinkedListLinkedList底层是双链表结构； 单链表 如图中所示，在链表结构中，每一个节点都是一分为二，前面存放数据后面存放下一个节点的位置；而链表的最后一位没有下一节点的位置时，此时为null; 像这一种称为单向链表； 双向链表 而像图中这种称为双向链表，将一个节点分为三份，第一份放上一个节点的位置，中间放数据，最后放下一个节点的位置； 链表结构添加数据，删除数据效率更高；因为不管添加还是删除只需知道下一节点的位置就可以更改，而且不会改变其他位置的数据，但它查询数据是从头到尾；所以查询数据效率就偏低 常用方法： public void addFirst(E e)`:将指定元素插入此列表的开头。 public void addLast(E e)`:将指定元素添加到此列表的结尾。 public E getFirst()`:返回此列表的第一个元素。 public E getLast()`:返回此列表的最后一个元素。 public E removeFirst()`:移除并返回此列表的第一个元素。 public E removeLast()`:移除并返回此列表的最后一个元素。 点击显/隐代码 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Iterator;import java.util.LinkedList;/** * @Author: zzy * @Date: 2018/10/20 * @Version 1.0 */public class LinkedListTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt;linkedList = new LinkedList&lt;&gt;(); linkedList.addFirst("添加到开头"); linkedList.addLast("添加到结尾"); //获取 linkedList.getFirst(); linkedList.getLast(); //判断是否为空 linkedList.isEmpty(); for (String str:linkedList)&#123; System.out.println(str); &#125; Iterator it = linkedList.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125; //删除 linkedList.removeLast(); linkedList.removeFirst(); &#125;&#125; Vectorvector对于学习C语言的人来说肯定是不陌生；Vector的底层也是可变数组；它与ArrayList的区别是加了synchronized同步锁；线程是安全的；线程安全一般效率偏低;ArrayList与LinkedList都是线程不安全的。但是效率相对而言要高；之前提过ArrayList的底层数组是以每次扩容0,5倍，而Vector是扩容1倍； 常用方法：add(E e) 将指定的元素追加到此Vector的末尾 void add(int index, Object element) 在此向量的指定位置插入指定的元素。 int capacity()返回此向量的当前容量。 void clear()从此向量中移除所有元素。 boolean contains(Object elem)如果此向量包含指定的元素，则返回 true。 Object remove(int index) 移除此向量中指定位置的元素 String toString()返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式。 add(int index, E element) 在此Vector中的指定位置插入指定的元素 add(int index, E element)在此Vector中的指定位置插入指定的元素 点击显/隐代码 12345678910111213141516171819202122232425262728293031323334import java.util.Vector;/** * @Author: zzy * @Date: 2018/10/20 11:13 * @Version 1.0 */public class VectorTest &#123; public static void main(String[] args) &#123; Vector vector = new Vector(); vector.add(0,"A"); vector.add(1,"C"); //添加到最后 vector.add("B"); //返回长度 vector.capacity(); //移除 vector.remove(1); //判断包含 vector.contains("B");//false //字符串表示 System.out.println(vector.toString()); //清空 vector.clear(); &#125;&#125;]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>Collection</tag>
      </tags>
  </entry>
</search>
